## 大流join小流

本质可以理解为发生了数据倾斜

1. 过滤异常key
2. 拆分成多个流再与原来的流进行join
3. 打散key的分布
	1. 重新设计keyby时候的key生成算法
	2. 二次keyby后再进行join

如果是实现就知道另外一个流比较小，可以考虑的方式

1. 将每次进入的流都广播到大流的处理中
2. 将很小的流存储在keyed state中，然后根据join的条件查询出来

## 大状态的调优

在某些情况下，某些操作就会存储很大的状态，默认flink是将状态存储在内存中的，这种情况下就会出现oom或者状态一直在清理然后报错的问题，进行调优的思路。就算不oom，也会一直出现网络交换导致内网崩溃

1. 最简单的也是最快速的：
	1. 就是使用rockesdb来替换，但是这个之后rocksdb是所有节点共享的，当在整个flink作业中，存储的状态足够大的时候，能直接拖垮flink的计算
	2. embeddedrocksdbstatebackend：将rocksdb嵌入到每个执行的算子上去
2. 很多大状态都是发生在flinksql上，使用windows的情况，所以最好就是用代码改写这部分的实现，根据业务保留具体的数据或者只记录数据的引用

## 64k问题

flinksql执行的本质是flink本身将flinksql当做一个dsl，然后通过这个去生成代码（而且还是单文件，然后如果这个sql比较复杂，生产的代码文件