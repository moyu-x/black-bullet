## 常见的三种过期删除策略

### 立即删除

**redis一直遍历着所有被设置了过期时间的key，来检测是否已经到了过期时间，然后对它进行删除。**

**遍历/删除都会占用cpu的时间，如果刚好碰倒cpu很忙的时候，就会给cpu造成额外的压力，产生极大的性能消耗，同时也会影响读取操作。**

总结：**对内存友好，对cpu不友好。**

### 惰性删除

通过某个key查询数据的时候，**如果过期了，就删除这个key，返回不存在**

问题：如果这个key已经过期，而且是一个大key，**如果这个key不被访问，就会一直存在于数据库中**

### 定期删除

间隔一段时间扫描key，然后对过期的key进行删除

**定期轮询redis库中的时效性数据，采用随机抽取的策略，抽到过期的key就进行删除。**

特点1：**cpu性能占用设置有峰值，检测频率和自行控制**  
特点2：**内存压力不是很大，长期占用内存的冷数据会被持续清理**

## redis本身的过期删除策略

**Redis 选择「惰性删除+定期删除」这两种策略配和使用**，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

## 内存淘汰策略


Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。

1. 不进行数据淘汰的策略
	1. **noeviction**：是redis 3.0的默认淘汰策略
2. 进行数据淘汰的策略
	1. 对设置了过期时间进行的
		1. volatile-random
		2. volatile-ttl: 优先淘汰最早过期的键值
		3. volatile-lru
		4. volatile-lfu
	2. 对所有数据进行内存淘汰
		1. allkeys-random
		2. allkeys-lru
		3. allkeys-lfu

**在 LRU 算法中**，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。

**在 LFU 算法中**，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。

## 持久化

redis本身是一个基于内存的kv数据库，其持久化就是将内存中的数据保存在硬盘中，防止系统崩溃。

所以根据一般的常识，就可以分为全量和增量两种。

### RDB

RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

触发方式分为**自动触发**和**手动触发**

**如何保证数据一致性呢**：

RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

- **优点**
    - RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；
    - Redis加载RDB文件恢复数据要远远快于AOF方式；
- **缺点**
    - RDB方式实时性不够，无法做到秒级的持久化；
    - 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
    - RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
    - 版本兼容RDB文件问题；

### AOF

**AOF(_Append Only File_)**:  只记录写命令

而AOF日志采用写后日志，即**先写内存，后写日志**。

AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。

在执行后才写入日志的原因：

1. **避免额外的检查开销。**
2. **不会阻塞当前写操作命令的执行**

#### 三种写回策略

因为日志是要写到文件系统中，此时我们就可以想到和文件系统同步的三种方式，redis中的写回策略也用了这些模式，本质就是`fsync()`的调用时机：

1. Always：每一条命令同步AOF文件中一次
2. Everysec：在内存积累一秒的数据，然后一次性吸入
3. No：使用文件系统自己的策略进行写入，就是只把命令刷到缓冲区

选择方式：

- 如果要高性能，就选择 No 策略；
- 如果要高可靠，就选择 Always 策略；
- 如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。

![[assets/680ad6735224c0fe8d137dc6863348e6_MD5.jpeg]]


### AOF重写

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。

**在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件**

**如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染**，AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。


## 部署模式

### 主从

一个 master 可以有多个 salve 节点；salve 节点可以有 slave 节点，从节点是级联结构。

- 主从模式优缺点
    1. 优点: 主从结构具有读写分离，提高效率、数据备份，提供多个副本等优点。
    2. 不足: 最大的不足就是主从模式不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预。

最好是在主节点写，然后在从节点读取数据

### 哨兵

### 集群
