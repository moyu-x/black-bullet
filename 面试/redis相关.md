## 常见的三种过期删除策略

### 立即删除

**redis一直遍历着所有被设置了过期时间的key，来检测是否已经到了过期时间，然后对它进行删除。**

**遍历/删除都会占用cpu的时间，如果刚好碰倒cpu很忙的时候，就会给cpu造成额外的压力，产生极大的性能消耗，同时也会影响读取操作。**

总结：**对内存友好，对cpu不友好。**

### 惰性删除

通过某个key查询数据的时候，**如果过期了，就删除这个key，返回不存在**

问题：如果这个key已经过期，而且是一个大key，**如果这个key不被访问，就会一直存在于数据库中**

### 定期删除

间隔一段时间扫描key，然后对过期的key进行删除

**定期轮询redis库中的时效性数据，采用随机抽取的策略，抽到过期的key就进行删除。**

特点1：**cpu性能占用设置有峰值，检测频率和自行控制**  
特点2：**内存压力不是很大，长期占用内存的冷数据会被持续清理**

## redis本身的过期删除策略

**Redis 选择「惰性删除+定期删除」这两种策略配和使用**，以求在合理使用 CPU 时间和避免内存浪费之间取得平衡。

## 内存淘汰策略


Redis 内存淘汰策略共有八种，这八种策略大体分为「不进行数据淘汰」和「进行数据淘汰」两类策略。

1. 不进行数据淘汰的策略
	1. **noeviction**：是redis 3.0的默认淘汰策略
2. 进行数据淘汰的策略
	1. 对设置了过期时间进行的
		1. volatile-random
		2. volatile-ttl: 优先淘汰最早过期的键值
		3. volatile-lru
		4. volatile-lfu
	2. 对所有数据进行内存淘汰
		1. allkeys-random
		2. allkeys-lru
		3. allkeys-lfu

**在 LRU 算法中**，Redis 对象头的 24 bits 的 lru 字段是用来记录 key 的访问时间戳，因此在 LRU 模式下，Redis可以根据对象头中的 lru 字段记录的值，来比较最后一次 key 的访问时间长，从而淘汰最久未被使用的 key。

**在 LFU 算法中**，Redis对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt(Last Decrement Time)，低 8bit 存储 logc(Logistic Counter)。

## 持久化

redis本身是一个基于内存的kv数据库，其持久化就是将内存中的数据保存在硬盘中，防止系统崩溃。

所以根据一般的常识，就可以分为全量和增量两种。

### RDB

RDB持久化是把当前进程数据生成快照保存到磁盘上的过程，由于是某一时刻的快照，那么快照中的值要早于或者等于内存中的值。

触发方式分为**自动触发**和**手动触发**

**如何保证数据一致性呢**：

RDB中的核心思路是Copy-on-Write，来保证在进行快照操作的这段时间，需要压缩写入磁盘上的数据在内存中不会发生变化。在正常的快照操作中，一方面Redis主进程会fork一个新的快照进程专门来做这个事情，这样保证了Redis服务不会停止对客户端包括写请求在内的任何响应。另一方面这段时间发生的数据变化会以副本的方式存放在另一个新的内存区域，待快照操作结束后才会同步到原来的内存区域。

- **优点**
    - RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；
    - Redis加载RDB文件恢复数据要远远快于AOF方式；
- **缺点**
    - RDB方式实时性不够，无法做到秒级的持久化；
    - 每次调用bgsave都需要fork子进程，fork子进程属于重量级操作，频繁执行成本较高；
    - RDB文件是二进制的，没有可读性，AOF文件在了解其结构的情况下可以手动修改或者补全；
    - 版本兼容RDB文件问题；

### AOF

**AOF(_Append Only File_)**:  只记录写命令

而AOF日志采用写后日志，即**先写内存，后写日志**。

AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。

在执行后才写入日志的原因：

1. **避免额外的检查开销。**
2. **不会阻塞当前写操作命令的执行**

#### 三种写回策略

因为日志是要写到文件系统中，此时我们就可以想到和文件系统同步的三种方式，redis中的写回策略也用了这些模式，本质就是`fsync()`的调用时机：

1. Always：每一条命令同步AOF文件中一次
2. Everysec：在内存积累一秒的数据，然后一次性吸入
3. No：使用文件系统自己的策略进行写入，就是只把命令刷到缓冲区

选择方式：

- 如果要高性能，就选择 No 策略；
- 如果要高可靠，就选择 Always 策略；
- 如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略。

![[assets/680ad6735224c0fe8d137dc6863348e6_MD5.jpeg]]


### AOF重写

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。

AOF 重写机制是在重写时，读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。

**在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件**

**如果 AOF 重写过程中失败了，现有的 AOF 文件就会造成污染**，AOF 重写过程，先重写到新的 AOF 文件，重写失败的话，就直接删除这个文件就好，不会对现有的 AOF 文件造成影响。


## 部署模式

### 主从

一个 master 可以有多个 salve 节点；salve 节点可以有 slave 节点，从节点是级联结构。

- 主从模式优缺点
    1. 优点: 主从结构具有读写分离，提高效率、数据备份，提供多个副本等优点。
    2. 不足: 最大的不足就是主从模式不具备自动容错和恢复功能，主节点故障，集群则无法进行工作，可用性比较低，从节点升主节点需要人工手动干预。

最好是在主节点写，然后在从节点读取数据

### 哨兵


其部署架构主要包括两部分：Redis Sentinel 集群和 Redis 数据集群。

其中 Redis Sentinel 集群是由若干 Sentinel 节点组成的分布式集群，可以实现故障发现、故障自动转移、配置中心和客户端通知。

Redis Sentinel 的节点数量要满足 2n+1(n>=1)的奇数个。

- 哨兵模式的作用：
    - 监控所有服务器是否正常运行：通过发送命令返回监控服务器的运行状态，处理监控主服务器、从服务器外，哨兵之间也相互监控。
    - 故障切换：当哨兵监测到 master 宕机，会自动将 slave 切换成 master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换 master。同时那台有问题的旧主也会变为新主的从，也就是说当旧的主即使恢复时，并不会恢复原来的主身份，而是作为新主的一个从。

优点：哨兵模式是基于主从模式的，解决可主从模式中master故障不可以自动切换故障的问题。

缺点：
1. 是一种中心化的集群实现方案：始终只有一个Redis主机来接收和处理写请求，写操作受单机瓶颈影响。
2. 集群里所有节点保存的都是全量数据，浪费内存空间，没有真正实现分布式存储。数据量过大时，主从同步严重影响master的性能。
3. Redis主机宕机后，哨兵模式正在投票选举的情况之外，因为投票选举结束之前，谁也不知道主机和从机是谁，此时Redis也会开启保护机制，禁止写操作，直到选举出了新的Redis主机。

### 集群

Redis Cluster 是一种服务器 Sharding技术 (分片和路由都是在服务端实现)，采用多主多从，每一个分区都是由一个 Redis 主机和多个从机组成，片区和片区之间是相互平行的。Redis Cluster 集群采用了 P2P 的模式，完全去中心化。

官方推荐，集群部署至少要 3 台以上的 master 节点，最好使用 3 主 3 从六个节点的模式。Redis Cluster 集群具有如下几个特点：

- 集群完全去中心化，采用多主多从；所有的 redis 节点彼此互联 (PING-PONG 机制)，内部使用二进制协议优化传输速度和带宽。
- 客户端与 Redis 节点直连，不需要中间代理层。客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。
- 每一个分区都是由一个 Redis 主机和多个从机组成，分片和分片之间是相互平行的。
- 每一个 master 节点负责维护一部分槽，以及槽所映射的键值数据；集群中每个节点都有全量的槽信息，通过槽每个 node 都知道具体数据存储到哪个 node 上。


## Redis中的事物

Redis事务的实现主要通过`MULTI`、`EXEC`和`WATCH`三个命令实现，其中`MULTI`用于开启事务，`EXEC`用于提交事务、`WATCH`用于监视任意数量的key。

Redis事务实现的一个核心结构是**事务队列**，当服务器以事务状态运行时，针对于接收到的不同命令会有不同的操作：

- 如果是`MULTI`、`EXEC`、`WATCH`和`DISCARD`其中的任意一个，服务器立刻执行
- 如果不是上述的四个命令，那么服务器就会将其放入到一个事务队列中，然后向服务器返回`QUEUED`恢复，表示命令已经入队，等待执行

redis事务与传统事务的不同

![[assets/bed77bd9ace00190e6d53c65d40d0432_MD5.jpeg]]

![[assets/be2f5f6d7f3a19aca2a45603ad7f10c6_MD5.jpeg]]

## 实现消息队列

1. list 结构：基于 list 结构模拟消息队列
2. pubsub：点对点消息模型
3. stream：比较完善的消息队列模型

### list的实现

使用lpush发布消息，使用rpop消费数据，使用bpop进行拉去消息的阻塞

### 基于pub-sub模式

Redis 提供了以下命令来完成发布、订阅的操作：

- `SUBSCRIBE`：订阅一个或多个频道
- `UNSUBSCRIBE`：取消订阅一个或多个频道
- `PSUBSCRIBE`：订阅一个或多个模式
- `PUNSUBSCRIBE`：取消订阅一个或多个模式

在此模式下有两种实现方式

一种是使用channel来进行发布订阅

另外一种是使用Patterm模式匹配发布定义（相当于同时监听多个channel）

**Pub/Sub 最大的优势就是，支持多组生产者、消费者处理消息；最大问题是：丢数据**

如果发生以下场景，就有可能导致数据丢失：

- 消费者下线
- Redis 宕机
- 消息堆积

当你在使用 Pub/Sub 时，一定要注意：消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。Pub/Sub 的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，Pub/Sub 的数据也会全部丢失

### 基于Stream的

在5.0中才进行支持。

Stream 本质上是 Redis 中的 key，相关指令根据可以分为两类，分别是消息队列相关指令，消费组相关指令。

stream本身有一个XACK的命令，可以在数据消费完成后告知redis，这样就能保证数据不丢失


![[assets/ae1881d679d703516d7f706e7ed92310_MD5.jpeg]]


## sorted set

`sorted set`有序集合和集合一样也是 string 类型元素的集合，同时也不允许有重复的成员。

不同的是`sorted set`中的每个元素都会关联一个 double 类型的分数，`sorted set`通过这个分数给集合中的成员进行从小到大的排序。有序集合中的成员是唯一的，关联的 score 可以重复。

他本身的底层使用了跳跃表的形式

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，**按照区间来查找数据这个操作，红黑树的效率没有跳表高**。

对于按照区间查找数据这个操作，跳表可以做到 **O(logn)** 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，这样高效大大提升。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，**跳表更容易代码实现**。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，**跳表更加灵活**，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

我觉得就是单纯的在redis的高频场景下，红黑树需要再平衡引起的

## 分布式锁

setnx+expire是两部操作，所以不要使用

1. 使用lua脚本（在里面写setnx和expire两条指令)
2. `SET key value[EX seconds][PX milliseconds][NX|XX]`在新版redis中使用
3. redlock算法：假设Redis的集群有5个节点，取当前的毫秒级时间戳，然后依次在所有节点中设置key，设置成功的误差不能太大，当3个节点(n/2-1)成功后，就相当于获取锁
## 缓存雪崩、击穿、穿透

缓存雪崩：当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**，大量请求直接到了数据库上
解决：
- 大量数据同时过期
	- 均匀设置过期时间：在数据过期的
	- 互斥锁
	- 后台更新缓存