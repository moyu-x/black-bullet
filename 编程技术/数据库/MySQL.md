### 获取 13 位时间戳

```sql
UNIX_TIMESTAMP() * 1000
```

## 导出

### 增加条件

使用`--where=`

### 不要主键

使用`--skip-add-drop-table --skip-extended-insert`

### 不要建表语句

使用`--no-create-info`

# 分表

测试可以发现，一般情况下，三层索引和四层索引之间没有明显的性能差异（数据 1k， buffer pool 配置为 22G），但是现实世界中没有那么完美，总有些原因：

1. 为了节省空间和保持扩展性，大多数短字符串类型采用 varchar 而非定长的 char，导致最底层的每一页包含的数据行数不一致，使平衡多路查找树不平衡
2. 生产表经常面临数据删除和更新
3. 使用时间越长的表，ibd 文件中的碎片越多，极端情况下会使数据页的缓存几乎失效
4. 磁盘上单文件体积过大不仅在读取 IOPS 上不如多文件，还会引发文件系统的高负载：单个文件描述符也是一种“单点”，大文件的读写性能不佳，还容易浪费大量内存

从软件工程方面给个结论：

> 能不分就不分，不到万不得已不搞分表，如果能通过加索引或加内存解决就不考虑分表，分表会对业务代码产生根本性的影响，并带来长期的技术债务。


# Buffer Pool 应该怎么优化

1. 内存配置的越大越好
2. 减少对冷数据的随机调用
3. 在大批量执行 update 语句的时候，尽量自己控制事务
4. 避免修改主键


## MyISAM和InnoDB区别

MyISAM是5.5之前的默认引擎，虽然性能极佳，而且提供了全文索引、压缩、空函数等特性，但是不支持书屋和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

1. MyISAM不支持行级锁，InnoDB支持行级锁，且默认为行级锁
2. MyISAM为了性能，每次查询具有原子性，但不提供事务；InnoDB提供事务支持
3. MyISAM不支持外键，而InnoDB支持外键
4. InnoDB支持MVCC，但只在`READ_COMMITED`和`REPLATABLE_READ`两个隔离级别下支持

MyISAM比InnoDB快这类经验之谈不绝对，在很多场景下InnoDB的速度高于MyISAM，尤其是在聚簇索引的情况下

## 索引

MySQL使用的索引主要有BTree索引和哈希索引。在绝大多数需要为单条记录查询的时候，可以选择哈希索引，查询性能最快，其他情况使用BTree索引。

MySQL的BTree索引使用是B+ Tree，但在两个引擎上面是不同的：

- MyISAM：B+ Tree叶节点的data域存放的是数据记录的地址。在检索索引的时候，首先按照B+ Tree的搜索算法搜索索引，如果指定的key存在，则取出data域的值，然后以data域的值作为地址读取相应的数据记录，这被成为非聚簇索引
- InnoDB：其数据文件本身就是索引文件。表数据文件是按照B+ Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录，而这个索引的key是数据表的主键，因此InnoDB表数据文件的本身就是主索引，这被成为聚簇索引。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。

在使用InnoDB时，如果没有显示指定表的主键时，InnoDB会先自动检查表中是否有唯一索引主键，有则使用该字段为默认主键，否则会创建一个6Byte的自增主键。

### 覆盖索引

如果一个索引包含索要查询字段的值，就称为覆盖索引。此时在InnoDB做存储引擎的情况下，就不用进行回表操作。

### 索引的缺点

1. 创建索引和维护索引需要耗费许多时间
2. 占用物理存储空间

### 哈希索引的优劣

优点是可以根据哈希函数快速定位数据所在位置，但是缺点是不能支持顺序查找和范围查找，这个是哈希函数原理有关

## 缓存

开启查询缓存后再同样查询条件以及数据的情况下，会直接再缓存中返回结果。缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。

## 事务

### 概念

事务时逻辑上的一组操作，要么都执行，要么都不执行

1. 原子性：事务时最小的执行单元，不允许分割。事务的原子性确保动作要么全部完成，要么全部失败
2. 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果时相同的
3. 隔离性：并发访问数据库时，一个用户的事务不干扰其他事务的执行，各个事务之间是相互独立的
4. 持久性：一个事务被提交之后，他对数据库的中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

事务带来的问题：

1. 脏读：A事务访问了数据并对其进行修改还未提交，B对相同数据进行了读取，然后使用了这个数据，那么B事务可能读到A事务未提交的数据，也就是脏数据
2. 丢失数据：A事务对一个数据进行读取修改时，B事务也对此数据进行读取修改，那么B事务可能直接覆盖A事务的结果导致A事务数据的丢失。
3. 不可重复度：A事务对数据进行多次读取，B事务对同数据进行修改，会发生A事务多次读取数据不一致的情况
4. 幻读：A事务读取多行数据，B事务在数据间插入或删除数据，这个时候A事务多个一些原本目标不存在的数据

不可重复读发生在对同一数据的读取和修改时候，幻读发生在多行数据的读取和删除新增的时候

### 隔离级别

1. READ-UNCOMMITTED
2. READ-COMMITTED
3. REPEATABLE-READ
4. SERIALIZABLE

MySQL InnoDB默认的事务隔离级别是REPEATABLE-READ，但是在此隔离级别下InnoDB使用的是Next-Key Lock算法，因此可以避免幻读，此情况其实以及达到了SERIALIZABLE的要求。在分布式事务的情况下一般会用到SERIALIZABLE隔离级别

## 优化

### 大表优化

MySQL的单表数据过大时，数据库的CRUD性能会明显下降，一些常见的措施时：

1. 限定数据范围
2. 读写分离
3. 垂直分表：根据数据库离数据的相关性进行拆分，将一张表拆为多张表。优点是可以是数据列变小，在查询时减少读取Block的数量，减少IO次数，简化表结构，利于维护。缺点时主键会出现冗余，造成大量的连接操作，让事务变得复杂
4. 水平分表：保持数据表的结构不变，通过存储策略，将没一片数据分散道不同的表或者库中，达到分布式的目的

但是尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

数据库分片的两种场景方案：

- 客户端代理：分片逻辑在应用端，封装在jar包中，或通过修改JDBC层来实现
- 中间件代理：在应用和数据库中加一个代理层。分片逻辑统一维护在中间件服务中。