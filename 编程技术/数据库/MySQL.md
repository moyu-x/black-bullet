### 获取 13 位时间戳

```sql
UNIX_TIMESTAMP() * 1000
```

## 导出

### 增加条件

使用`--where=`

### 不要主键

使用`--skip-add-drop-table --skip-extended-insert`

### 不要建表语句

使用`--no-create-info`

# 分表

测试可以发现，一般情况下，三层索引和四层索引之间没有明显的性能差异（数据 1k， buffer pool 配置为 22G），但是现实世界中没有那么完美，总有些原因：

1. 为了节省空间和保持扩展性，大多数短字符串类型采用 varchar 而非定长的 char，导致最底层的每一页包含的数据行数不一致，使平衡多路查找树不平衡
2. 生产表经常面临数据删除和更新
3. 使用时间越长的表，ibd 文件中的碎片越多，极端情况下会使数据页的缓存几乎失效
4. 磁盘上单文件体积过大不仅在读取 IOPS 上不如多文件，还会引发文件系统的高负载：单个文件描述符也是一种“单点”，大文件的读写性能不佳，还容易浪费大量内存

从软件工程方面给个结论：

> 能不分就不分，不到万不得已不搞分表，如果能通过加索引或加内存解决就不考虑分表，分表会对业务代码产生根本性的影响，并带来长期的技术债务。


# Buffer Pool 应该怎么优化

1. 内存配置的越大越好
2. 减少对冷数据的随机调用
3. 在大批量执行 update 语句的时候，尽量自己控制事务
4. 避免修改主键
