## 基础

### 为什么需要

1. 避免不同节点重复相同的工作
2. 避免破坏数据的正确性

### 为什么使用

1. 要性能的：拥有这把锁使得不会重复劳动，如果这把锁fail了，两个节点同时做了这个任务，增加了成本
2. 要正确性：拥有锁可以防止并发操作污染系统或者数据，如果这把锁fail了，两个节点同时操作了一份数据，结果可能数据不一致等严重后果

### 常见方案

1. 基于MySQL的锁
2. 基于Zookeeper有序节点
3. 基于Redis单线程

## Redis实现

### 超时锁

问题：

1. A服务获取锁后突然挂了，B服务永远不可能获取锁
2. 在加锁和释放锁之间的逻辑过长，超出了锁的时间限制，会出现不该获取锁的服务获取锁
3. 在GC的时候也有可能引发安全问题

解决：

1. Redis的分布式锁不要用于较长时间的任务
2. 讲锁的value设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除锁，确保当前线程占有的锁不会倍其他线程释放
3. 多个指令操作使用Lua脚本：释放锁的操作有多个指令，Redis的匹配和删除并不是原子操作，也没有替代指令，只能使用Lua脚本保证多个指令原子执行

### 单点/多点问题

采用单机模式部署，意味着Redis故障就会导致整个服务不可用。

主从部署会出现A申请到一个锁，这是主机崩溃，但是key还未同步，这时B就会从从机那里获取锁，不符合要求，这得是哟个RedLock算法的方式解决。

### 实现

**单节点**

在设置锁的时候，应当使用`set`的扩展指令方式`SET key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]`来设计锁，释放锁用Lua脚本实现

### 多节点

使用Redlock算法

### RedLock算法

1. 得到当前时间
2. 尝试顺序在5个实例上申请锁
3. 当在大于等于3个节点上申请到锁时，计算申请消耗时间，锁持续时间大于消耗时间就获取锁
4. 申请到锁后，真正的锁时间是`lock validity time`-申请锁耗时
5. 申请失败，就会在申请到锁的节点上执行释放锁操作，重置状态

RedLock很容易在client的GC时候出现问题，比如A获取锁，但是此过程种发生GC且时间超过锁超时时间，B在这种情况下会获取锁并操作数据，而A也会在GC结束后继续原操作，最后导致严重的数据问题。

### 结论

RedLock是不可靠的，要在满足网络延时、进程停顿和时钟错误的边界下才是可靠的。对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。

所以如果应用只需要高性能的分布式锁不要求多高的正确性，使用单节点的Redis就够用；如果还要保证正确性，应该使用一个合适的一致性协调系统。