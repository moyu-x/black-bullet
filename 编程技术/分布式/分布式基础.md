分布式系统的第一原则是不要分布，分布式系统的目标是提升系统的整体性能和吞吐量另外还要尽量保证分布式系统的容错性

**分布式**：一个业务拆分多个子业务，部署到不同的服务器上

**集群**：同一个业务，部署到多个服务器上

## 中心化

### 职责和角色

中心化的设计思想是讲分布式集群中的节点机器按照角色分工，答题上分为两种角色：领导和工作机器，leader负责分配任务，让worker去执行任务。微服务架构的Kubernetes用的就是这一思路

### 问题

1. leader安全问题，如果leader崩溃，整个集群就崩溃，但是难以同时安排两个leader以避免单点问题
2. leader的能力问题，如果leader设计的低效，整个系统也是低效的

解决办法：设计主备两个leader，可以是热备或者冷备，自动切换或者手动切换，或者使用leader选举机制。

## 去中心化

- 众生平等的地位
- 不是不要中心，而是由节点自由选择中心：由节点自主选举节点作为leader。
- “脑裂”问题：指由一个集群由于网络的故障，被分为至少两个独立的集群，此时两个集群独立工作，这就胡造成数据的严重冲突。一个解决思路是发生“脑裂”问题后，规模小的集群拒绝服务

## CAP

- 一致性（Consistence）：所有节点访问同一份最新的数据副本
- 可用性（Availability）：每次请求都能获取到飞错的相应，但是不保证获取最新数据
- 分区容错性（Partition tolerance）：分布式系统在遇到某节点或网络分区故障的时候，任然能够对外提供满足一致性和可用性的服务

当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能2选1。也就是说当网络分区之后P是前提，决定了P之后才有C和A的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。

## BASE理论

BASE是Basically Available（基本可用）、Soft-state（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。

### 核心思想

即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。

## 分布式事务

### 基于XA协议的两阶段提交

XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

XA协议比较简单，但是，XA也有致命的缺点，那就是性能不理想，特别是在交易下单链路，往往并发量很高，XA无法满足高并发场景。

### 消息事务+最终一致性

所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败。

过程：

1. A系统向消息中间件发送一条预备消息
2. 消息中间件保存预备消息并返回成功
3. A执行本地事务
4. A发送提交信息给消息中间件
5. 消息中间件保存要发送的消息，并发送消息到B
6. B执行本地事务

### TCC模式

其实两阶段提交的一个变种，TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。

### 本地事务

其核心思想是将分布式事务拆分成本地事务进行处理

消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

## Paxos

### 角色

- Proposer：只要Proposer发的提案被Acceptor接受，Proposer就认为该提案里的value被选定了
- Acceptor：只要Acceptor接受了某个提案，Acceptor就任务该提案里的value被选定了
- Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定

在具体的实现中，一个进程可能同时充当多种角色

Proposer可以提出提案；Acceptor可以接受提案