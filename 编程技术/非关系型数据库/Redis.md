## 基础

Redis是一个用C语言开发的内存数据库，除了作为缓存外，还可以用于分布式锁设计，消息队列的设计。

### 缓存穿透

缓存穿透是指有大量请求的key不存在于缓存中，导致直接请求到了数据库上，相当于实际上缓存没有存在（毕竟请求都直接到数据库了）

解决办法：

1. 做好参数校验
2. 缓存无效key，并设置一定的过期时间
3. 布隆过滤器

### 缓存雪崩

缓存在一定时间大面积失效，或热点数据在某一时刻失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受了大量请求。

### 布隆过滤器

布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。主要原因是哈希算法会导致一定概率上的两个字符串的哈希值相同。

当一个元素加入布隆过滤器时，会进行：

1. 使用布隆过滤器的哈希函数对元素进行计算，使用多个哈希函数多key进行运算，得到一个证书索引，然后对数组长度进行取模运算达到位置
2. 根据哈希值，将对应的数据下标置为1

使用时不要让实际元素远大于初始化数量，当实际元素远大于初始化数量时，应该重建布隆过滤器，然后分配一个更大的初始值

### 单线程模型

Redis是基于Reactor模式来设计的一套高效的事件处理机制，通过IO多路复用来监听多个Socket，并根据套接字执行的任务来为套接字关联不同的事件处理器，降低了资源的消耗

### 多线程

6.0之前不使用的原因：

1. 单线程编程利于维护
2. Redis的性能瓶颈在内存和网络
3. 多线程会存在死锁、线程上下文切换的问题，甚至会影响性能

6.0引入多线程主要是为了提高网络IO读写性能，但是Redis的多线程只是在网络数据读写这类耗时操作上使用，并且默认是禁用的

### 数据过期

Redis通过维护一个过期字典来保存过期时间，过期字典的键指向Redis中的某个key，值是过期的时间

删除策略：

1. 惰性删除：只在取出key的时候才对数据进行检查。对CPU友好但是会造成太多过期key没被删除
2. 定期删除：每隔一段时间定期的取出一批key执行过期删除操作

### 内存淘汰机制

1. volatile-lru：从已设置过期的数据集中挑选最近最少使用的数据进行淘汰
2. volatile-ttl：从已设置过期的数据集中挑选将要过期的进行淘汰
3. volatile-random：从已设置过期的数据集中任意选择数据淘汰
4. allkeys-lru：当内存不足以容纳新数据时，移除最近做少使用的key（这个最常用）
5. allkeys-random：从数据集中任意淘汰数据
6. no-eviction：禁止数据淘汰，当数据不足以容纳新数据写入时，新写入会报错
7. volatile-lfu：从已经设置过期的数据集中挑选最少使用的数据淘汰
8. allkeys-lfu：当内存不足以容纳写入的新数据时，移除最少使用的key

### 持久化机制

1. 快照（RDB）：默认持久化方式，可以通过创建快照来获得存储在内存里数据在某个时间点上的副本。
    
    Redis会在持久化时调用glibc函数fork产生一个子进程，快照持久化由子进程处理，主进程还是继续处理客户端请求。子进程复制过程种使用cow机制，将数据存储的内存段复制出来进行持久化，此后主线程对此数据段的修改不影响复制。
    
2. 追加文件（AOF）：主流持久化方式，将Redis执行的更改命令写入到硬盘的AOF文件中
    

Redis 4.0开始可以使用混合持久化机制

### 事务

Redis可以通过`MULTI`、`EXEC`、`DISCARD`和`WATCH`等命令来实现事务。

`MULTI`：在使用后，不会立即执行这些命令，而是放入到独立，当调用`EXEC`命令将执行所有命令

### 缓存和数据库一致性

旁路缓存模式：更新数据库，然后删除缓存。

如果删除缓存这一步失败，解决方案如下：

1. 减少缓存失效时间，但是治标不治本
2. 增加cache更新重试机制，进行多次重试，如果还失败，就放入队列中，等缓存服务可用后再重试

## 数据结构

### String

string数据结构是简单的kv类型，虽然使用C实现的，但是Redis本身自己构建了一种简单动态字符串来实现此结构

C字符串的缺陷：C语言使用`n+1`字符数组来表示n的字符串，最后一位位`\\0`，其不保存字符串长度，导致获取字符串长度的操作位$O(n)$，不能很好的杜绝缓冲区溢出问题，并且由于时ASCII的原因，只能保存文本数据。

Redis的规定字符串的长度不能超过512M。

### list

Redis中的list是一个双向链表的实现。可以用来实现发布定义、消息队列

### hash

特别适合用于存储对象。使用拉链法来解决冲突。

**扩容**

使用渐进式rehash的方式来进行扩容，会在rehash的同时，保留两个hash结构，查询时会同时查询两个hash结构体，然后在后续的定时任务以及hash操作中，循序渐进的把字典的内容迁移到新字典中。当迁移完成，会使用新结构替代。

默认情况下，元素的个数等于第一维数组的长度时就扩容，新数组是原数组大小的2倍。

### set

set提供了判断某个成员是否在一个 set 集合内的重要接口

### sorted set

有一个score参数，使得集合可以按照score进行有序排列，还可以通过score的范围来获取元素，用于需要去重但是还要根据某个权重进行排序的场景。

## Redis Cluster

- 自动将数据进行分片，每个master上放一部分数据
- 提供内置的高可用支持，部分master不可用时，还能继续工作

在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加1w 的端口号，比如 16379。

### 节点间通信原理

1. 集中式：将集群元数据存储在某个节点上
2. gossip：gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力；不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。

### 寻址算法

1. hash算法：首先对key计算hash值，然后对节点数取模。但是一个节点宕机，就会导致从新节数进行取模，最后使大部分请求都无法有效的缓存
2. 一致性hash算法：将整个hash值空间组成一个虚拟环并按照顺时针方向进行排列，对各个master节点进行hash，就能确定每个节点在hash环上的位置。所以key请求的时候，先计算hash值，确定数据在环上的位置，并按照顺时针行走，遇到的第一个master节点就是key所在位置。但是在节点过少的情况下，会导致数据分布不均匀，从而有可能发生大量数据分配在同一个节点上的情况。
3. hash slot算法：Redis cluster有固有的16384个hash slot，对每个key进行crc16计算，然后对16384取模，算出key对应的hash slot

### 高可用

1. 判断节点宕机：主管宕机和客观宕机
2. 从节点过滤：对宕机的master node，从其slave node中，选择一个切换成master node
3. 从节点选举：每个从节点，都根据自己对 master 复制数据的 offset，来设置一个选举时间，offset 越大（复制数据越多）的从节点，选举时间越靠前，优先进行选举。