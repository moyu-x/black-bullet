![[ae274b7e0bec679db011179b58aa01d9_MD5.jpeg]]

Java 底层初始桶的个数是16个，负载因子默认是0.75，也就是说当键值第一次达到12个的时候就会进行扩容 resize。扩容的临界值在64，当超过了64以后，并且冲突节点为8或者大于8，这个时候就会触发红黑树转换。为了防止底层链表过长，链表就转换为红黑树。

换句话说，当桶的总个数没有到64个的时候，即使链表长为8，也不会进行红黑树转换。

如果节点小于6个，红黑树又会重新退化成链表。

当然这里之所以选择用红黑树来进行优化，保证最坏情况不会退化成  
O(n)，红黑树能保证最坏时间复杂度也为 O(log n)。

在美团博客中也提到了，Java 在 JDK1.8 中还有一个值得学习的优化。Java 在 rehash 的键值节点迁移过程中，不需要再次计算一次 hash 计算！


ref:

- https://halfrost.com/go_map_chapter_one/#toc-14
- 
