## 悲观锁

总是假设最坏的情况，每次去拿数据都认为数据本身会被其他线程修改，所以在每次操作的时候都进行上锁。比如`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

## 乐观锁

在获取资源的时候认为不会被修改，在修改资源的时候认为会出现冲突，所以在修改的时候获取锁。此类型的锁多用于读多写少的情况，有利于提高吞吐量，如`Atomic`类

### 实现机制

1. 版本号机制，如JPA中的`@Version`注解，在每次修改的时候都要要读取`@Version`字段，只有在修改后此字段值保持不变才提交，否则进行重试，直至成功
2. CAS算法

### 缺点

1. ABA问题：假设两个线程a, b的目标都是将x减少一半，由于读取数据的时候不会上锁，这个时候两个线程都是将x修改的1/2x，a首先进行cas操作提交，此时对于b来说要等待操作，当b获取锁的时候，发现目标数据已经是1/2x了，认为操作已经成功，则不会重新操作，此时b线程的不能确定数据是否被修改而保持不变，改变了b线程本身的操作语义。同理的还有[如下情况](https://juejin.im/post/6844903796129136647)：
    
    小明在提款机，提取了50元，因为提款机问题，有两个线程，同时把余额从100变为50 线程1（提款机）：获取当前值100，期望更新为50， 线程2（提款机）：获取当前值100，期望更新为50， 线程1成功执行，线程2某种原因block了，这时，某人给小明汇款50 线程3（默认）：获取当前值50，期望更新为100， 这时候线程3成功执行，余额变为100， 线程2从Block中恢复，获取到的也是100，compare之后，继续更新余额为50！！！ 此时可以看到，实际余额应该为100（100-50+50），但是实际上变为了50（100-50+50-50）这就是ABA问题带来的成功提交。
    
    解决方法： 在变量前面加上版本号，每次变量更新的时候变量的版本号都+1，即A->B->A就变成了1A->2B->3A。
    
2. 循环等待的时间过长，最终导致线程饥饿
    
3. 只能保重一个变量的原子操作
    

## AQS(AbstractQueuedSynchronizer)

提供一个框架，用于实现依赖于FIFO等待队列的阻塞锁和同步器。这个类设计的大多数同步操作依赖于atomic int值表示状态。子类必须定义受保护的方法去改变这个状态，并定义该状态堆要获取或释放的对象，此类中的其他方法将执行排队阻塞机制。子类可以维护其他状态，但就同步而已，使用`getState`、`setState`和`compareAndSetState`操作更新值。

默认支持独占模式或共享模式。在独占模式下，其他线程尝试获取锁不会成功。

### 原理

AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。

CLH队列是一个虚拟的双向队列，只存在节点之间的联系，但是不存在实质的队列实例。

在其节点的前驱中保存着线程的一些控制信息，`status`字段跟踪线程是否应该被阻塞，节点的前驱被释放时，通过信号进行通知。否则，队列中的每个节点充当持有单个等待线程的特定通知的监视器。

将节点加入CLH队列中，拼接到最后形成新的尾部就行，要出队，修改head字段就行。

```
            +------+  prev +-----+       +-----+
       head |      | <---- |     | <---- |     |  tail
            +------+       +-----+       +-----+
```

### 资源共享方式

1. Exclusive（独占）只有一个线程能执行，又可以分为公平锁和非公平锁
2. Share（共享）：多个获取锁的线程可以同时执行

### 使用模板方法

AQS本身就是个抽象类，所以可以作为其他同步器的模板，只需继承并重写特定的方法就行。当然为了防止子类为实现相关的方法，在模板方法中未实现情况下将抛出异常，而非模板方法则用`final`进行修饰，防止子类重写。

模板方法如下

## ReentrantLock

### 公平锁和非公平锁

公平锁：按照线程在队列中的排队顺序，先到先获取锁

非公平锁：每次一个线程要获取锁，通过两次cas操作去获取锁，没有获取到，则将此线程放到队列中

### 实现区别

`state`是用`volatile`修饰的。

非公平锁（NonfairSync）：调用`lock`后，会使用cas抢占锁`compareAndSetState(0, 1)`，获取锁则进行返回，没有则调用`acquire`方法。

公平锁（FairSync）：会直接调用`acquire`方法

```java
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
```

会以独占的方式获取锁，忽略中断。通过至少一次`tryAcquire`实现，成功则返回，否则线程将排队。可能会重复阻塞和接触阻塞，直到`tryAcquire`成功。

`ReentrantLock`在实现AQS时将`tryAcquire`在`NonfairSync`和`FairSync`重写，不同的是非公平中调用`getState`后，为0说明没有持有锁，用cas抢占锁；而公平锁则会有一个前置判断当前队列有没有等待线程，然后采取强制锁，以此保证公平性；后续操作两锁都是一直的。

非公平锁会发生每一个新任务都能抢占到锁，从而导致等待队列中的任务一直不能执行而长期处于饥饿。

## Semaphore

一种信号计数器，维护一组许可，每个线程先获取许可，然后执行，结束后会释放这个许可，没有获取许可的会等待。Semaphore通常用于限制访问某些资源的线程数量。其支持公平模式和非公平模式。

由于能支持多个线程获取锁，所以用的共享模式

使用内部类`Sync`去实现`AbstractQueuedSynchronizer`，实现基本的操作类；用`NonfairSync`去实现非公平模式，`FairSync`实现公平模式，这两个类继承于`Sync`

两个构造器，都需要传入许可的数量，其中一个构造器可以指定公平和非公平模式。

## CountDownLatch

允许一个多个线程等待，直到其他线程执行完毕。使用给定的数初始化`CountDownLatch`，初始化为N的`CountDownLatch`可以让一个线程等待，直到N个线程完成某个操作，或某个操作完成N次。

### 原理

一个典型的用法就是将问题分为N个部分，用执行该部分并在锁存器上倒计时的`Runable`描述每个部分，然后将所有的线程排列到一个执行器上，当所有子部分执行完毕时，其他任务继续执行（前提时各个部分能相互独立执行）

利用AQS中的`state`作为`count`，当线程使用`CountDownLatch`时，其相当于调用`tryReleaseShared`方法。`tryReleaseShared`在内部获取`state`状态，用CAS方式减少`state`，直至`state`为0，就代表所有方法都调用了`countDown`方法，其于方法可以继续执行。

调用await的线程，会阻塞调用线程的执行，直到state为0。当发现部位0的时，除非线程被终端，否则将线程放入阻塞队列，自旋判断state是否为0。

### 不足

其本身设计时一次性的，也就是state为0时候后续的就不会被阻塞了，也没有重置机制。

## CyclicBarrier

一个允许一组线程彼此等待达到共同的屏障点的同步辅助工具。屏障的每次使用都会生产一个实例。

### 原理

在代码内部使用`ReentrantLock`和`Condition`进行实现。在构造函数中，`parties`代表了能等待线程的数量。如果需要在所有线程达到屏障点时执行统一操作，可以使用构造器中的`barrierAction`，传入需要执行的内容。

当调用`CyclicBarrier`的`await`方法时，实际上时在调用`dowait`方法。在`dowait`内部，先减少`count`值，当为0的时候就表示最后一个线程到达栅栏，就开始执行`barrierAction`，最后用`breakBarrier`取消所有任务的阻塞。否则就在循环内部进行阻塞，直到线程被发布，中断或者超时