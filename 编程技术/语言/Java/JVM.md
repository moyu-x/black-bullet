# JIT

为了使 CPU 的内部运算单元能够被充分利用，处理器可能对 输入的字节码指令进行重新排序，这也叫 处理器优化。（比如，jvm 的即时编译 JIT）

# 设计哲学

1. 平台无关性
2. 内存管理
3. 安全性
4. 多线程
5. 性能优化
6. 跨平台开发

---
以下为老笔记
# JVM


## 基础

在运行过程中，每当调用进入一个 Java 方法，Java 虚拟机会在当前线程的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数。这个栈帧的大小是提前计算好的，而且 Java 虚拟机不要求栈帧在内存空间里连续分布。当退出当前执行的方法时，不管是正常返回还是异常返回，Java 虚拟机均会弹出当前线程的当前栈帧，并将之舍弃。

Hotspot 中运行形式：一种是解释执行，第二种是及时编译

即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。

从 Java 7 开始，HotSpot 默认采用分层编译的方式：热点方法首先会被 C1 编译，而后热点方法中的热点会进一步被 C2 编译。

Java 虚拟机将运行时内存区域划分为五个部分，分别为方法区、堆、PC 寄存器、Java 方法栈和本地方法栈。Java 程序编译而成的 class 文件，需要先加载至方法区中，方能在 Java 虚拟机中运行。

## 基本类型

[![[assets/0b5f8e962f6b046ef73b7bc619969049_MD5.jpg]]](https://idwangmo-notes.oss-cn-shanghai.aliyuncs.com/IMGS/20200208161227.png)

一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN。一般我们计算得出的 NaN，比如说通过 +0.0F/+0.0F，在内存中应为 0x7FC00000。这个数值，我们称之为标准的 NaN，而其他的我们称之为不标准的 NaN。

对于供解释器使用的栈帧，主要由两个组成的部分，分布式局部变量区，以及字节码的操作数栈。

在 Java 虚拟机规范中，局部变量区等价于一个数组，并且可以用正整数来索引。除了 long、double 值需要用两个数组单元来存储之外，其他基本类型以及引用类型的值均占用 一个数组单元。这种情况仅存在于局部变量，而并不会出现在存储于堆中的字段或者数组元素上。对 于 byte、char 以及 short 这三种类型的字段或者数组单元，它们在堆上占用的空间分别为 一字节、两字节，以及两字节，也就是说，跟这些类型的值域相吻合。

boolean 字段和 boolean 数组则比较特殊。在 HotSpot 中，boolean 字段占用一字节，而 boolean 数组则直接用 byte 数组来实现。为了保证堆中的 boolean 值是合法的，HotSpot 在存储时显式地进行掩码操作，也就是说，只取最后一位的值存入 boolean 字段 或数组中。

对于 boolean、char 这两个无符号类型来说，加载伴随着零扩展。对于 byte、short 这两个类型来说，加载伴随着符号扩展。

## 类加载

从 class 文件到内存中的类，按先后顺序需要经过加载、链接以及初始化三大步骤。

对于引用类型，Java 将其细分为四种：类、接口、数组类和泛型参数。泛型参数会在编译过程中被擦除，因此 Java 虚拟机实际上只有前三种引用类型。在类、接口和数组类中，数组类是由 Java 虚拟机直接生成的，其他两种则有对应的字节流。

### 加载

**加载：**指查找字节流，并且据此创建类的过程。

加载需要借助类加载器，在 Java 虚拟机中，类加载器使用了双亲委派模型，即接收到加载请求时，会先将请求转发给父类加载器。

对于数组类来说，它并没有对应的字节流，而是由 Java 虚拟机直接生成的。对于其他的类来说，Java 虚拟机则需要借助类加载器来完成查找字节流的过程。

除了启动类加载器之外，其他的类加载器都是 `java.lang.ClassLoader`的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。

在 Java 9 之前，启动类加载器负责加载最为基础、最为重要的类，比如存放在 JRE 的 lib 目录下 jar 包中的类。扩展类加载器的父类加载器是启动类加载器，它负责加载相对次要、但又通用的类，比如存放在 JRE 的 lib/ext 目录下 jar 包中的类；应用类加载器的父类加载器则是扩展类加载器。它负责加载应用程序路径下的类。（这里的应用程序路径，便是指虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。）默认情况下，应用程序中包含的类便是由应用类加载器加载的。

Java 9 引入了模块系统，并且略微更改了上述的类加载器[1](https://docs.oracle.com/javase/9/migrate/toc.htm#JSMIG-GUID-A868D0B9-026F-4D46-B979-901834343F9E)。扩展类加载器被改名为平台类加载器（platform class loader）。Java SE 中除了少数几个关键模块，比如说 java.base 是由启动类加载器加载之外，其他的模块均由平台类加载器所加载。

在 Java 虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。

### 链接

**链接**，是指将创建成的类合并至 Java 虚拟机中，使之能够执行的过程。它可分为验证、准备以及解析三个阶段。

在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。

解析阶段的目的，正是将这些符号引用解析成为实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段或方法，那么解析将触发这个类的加载（但未必触发这个类的链接以及初始化。）

### 初始化

**初始化**，则是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。类的初始化仅会被执行一次，这个特性被用来实现单例的延迟初始化。

在 Java 代码中，如果要初始化一个静态字段，我们可以在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被 final 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 < clinit >。

类加载的最后一步是初始化，便是为标记为常量值的字段赋值，以及执行 < clinit > 方法的过程。Java 虚拟机会通过加锁来确保类的 < clinit > 方法仅被执行一次。

只有当初始化完成之后，类才正式成为可执行的状态。

JVM 规范枚举了下述多种触发情况：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## 方法调用

### 重载与重写

重载的方法在编译过程中即可完成。具体到每一个方法调用，Java 编译器会根据所传入参数的声明类型来选取重载方法。选取的过程共分为三个阶段：

1. 在不考虑对基本类型自动装拆箱（auto-boxing，auto-unboxing），以及可变长参数的情况下选取重载方法；
2. 如果在第 1 个阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法；
3. 如果在第 2 个阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法。

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，其关系为：如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。

### 静态绑定和动态绑定

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法 [2] 来实现 Java 中的重写语义。

Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java 字节码中与调用相关的指令共有五种。

1. invokestatic：用于调用静态方法。
2. invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法。
3. invokevirtual：用于调用非私有实例方法。
4. invokeinterface：用于调用接口方法。
5. invokedynamic：用于调用动态方法。

对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 C 中查找符合名字及描述符的方法。
2. 如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
3. 如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。

1. 在 I 中查找符合名字及描述符的方法。
2. 如果没有找到，在 Object 类中的公有实例方法中搜索。
3. 如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

### 方法表

方法表满足两个特质：其一，子类方法表中包含父类方法表中的所有方法；其二，子类方法在方法表中的索引值，与它所重写的父类方法的索引值相同。

使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者，读取调用者的动态类型，读取该类型的方法表，读取方法表中某个索引值所对应的目标方法。相对于创建并初始化 Java 栈帧来说，这几个内存解引用操作的开销简直可以忽略不计。

### 内联缓存

## 异常处理

异常实例的构造十分昂贵。这是由于在构造异常实例时，Java 虚拟机便需要生成该异常的栈轨迹（stack trace）。该操作会逐一访问当前线程的 Java 栈帧，并且记录下各种调试信息，包括栈帧所指向方法的名字，方法所在的类名、文件名，以及在代码中的第几行触发该异常。

在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置。

当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。

如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。

## 反射

反射调用先是调用了 Method.invoke，然后进入委派实现（DelegatingMethodAccessorImpl），再然后进入本地实现（NativeMethodAccessorImpl），最后到达目标方法。

动态实现和本地实现相比，其运行效率要快上 20 倍。考虑到许多反射调用仅会执行一次，Java 虚拟机设置了一个阈值 15（可以通过 -Dsun.reflect.inflationThreshold= 来调整），当某个反射调用的调用次数在 15 之下时，采用本地实现；当达到 15 时，便开始动态生成字节码，并将委派实现的委派对象切换至动态实现，这个过程我们称之为 Inflation。



## 运行时数据区域

### 线程私有的

- 程序计数器
- 虚拟机栈
- 本地方法栈

### 线程共享的

- 堆
- 方法区
- 直接内存

**程序计数器**是唯一一个不会出现`OutOfMemoryError`的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。当一个线程正在执行一个Java方法的时候，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（`Undefined`）。

**Java 虚拟机栈**也是线程私有的，它的生命周期和线程相同，Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。

**局部变量表**主要存放了编译期可知的各种数据类型、对象引用

Java 虚拟机栈会出现两种错误：

1. `StackOverFlowError`
2. `OutOfMemoryError`

**虚拟机栈**为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

**堆**：此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。

在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：

- 新生代内存(Young Generation)
- 老生代(Old Generation)
- 永生代(Permanent Generation)

![[assets/0148aca2837e7bbdf9df41fc5a7892f6_MD5.jpeg]]

JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。

对象再Eden区域分配内存 → S0或S1 → 老年代

**用MetaSapce替换永久代**：

1. 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而MetaSpace使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小
2. 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了

### HotSpot虚拟机

对象创建：

1. 类加载检查
2. 分配内存：分配方式有指针碰撞和空闲列表。
3. 初始化零值
4. 设置对象头
5. 执行`init`方法

选择哪种内存分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩功能来决定

![[assets/a2620196519928527cf97cb283359f7a_MD5.jpeg]]

Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运就”行时数据，另一部分是类型指针。实例数据部分是对象真正存储的有效信息，对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用

### 常量池

String对象的两种创建方式：

```java
// 1. 从常量池中拿对象。先在常量池中检查有没有字符串，如果没有，则创建一个，然后指向该
// 常量池中的对象；如果有，则直接指向该常量池对象
String str1 = "abcd";

// 2. 在堆中创建一个新对象
String str2 = new String("abcd");
```

`String`类型的常量池主要使用两种方式：

1. 直接使用双引号声明出来的 `String`对象会直接存储在常量池中。
2. 使用String提供的 `intern`方法

`String str2 = new String("abcd");` 将会创建一个或两个字符串，如果常量池中存在“abcd”，则会在堆上创建一个字符串常量；如果常量池中不存在，则会先在常量池中创建，然后再堆空间中创建，总共创建两个字符串对象。

## 垃圾回收

### 对象分配

![[Pasted image 20250306235550.png]]


Java自动内存管理最核心的功能是堆内存中对象的分配与回收。

Openj9的实现`-XX:+PrintGCDetails`和`-Xverbosegclog`打印日志我没成功，在jdk11上要用`-Xlog:gc*`

**对象优先再`eden`区分配，大对象直接进入老年代，长期存活对象进入老年代，动态对象年龄判断。**

根据[R大的回答](https://www.zhihu.com/question/41922036)，需要问清Major GC指的是Full GC还是old GC

大对象直接进入老年代主要是避免大对象分配内存时由于分配担保机制带来的复制而降低效率。

进入到老年代的年龄[阈值](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)`parallel (throughput) collector`为15，CMS为6，可以通过`-XX:MaxTenuringThreshold`来进行设置

### 对象死亡判断

1. 引用计数法：实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题
    
2. 可达性分析：通过一系列的称为`GC Roots`的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到`GC Roots`没有任何引用链相连的话，则证明此对象是不可用的
    
    可作为GC Roots的对象：
    
    - 虚拟机栈中引用的对象
    - 本地方法栈中引用的对象
    - 方法区中类静态熟悉引用的对象
    - 方法区中常量引用的对象
    
    要表明一个对象真正可以回收，至少要警告两次标记过程
    

### 引用

1. 强引用(StrongReference)
2. 软引用(SoftReference)：如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
3. 弱引用(WeakReference)：在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。
4. 虚引用(PhantomReference)：虚引用主要用来跟踪对象被垃圾回收的活动。

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出等问题的产生。

### 判断类时无用类

要满足以下三个条件

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
- 加载该类的`ClassLoader`已经被回收。
- 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 标记-清除算法

首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

但是会产生两个问题：

1. 效率问题
2. 标记清除后产生大量不连续的碎片

### 复制算法

它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。

### 标记-整理算法

首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

### 分代收集算法

根据对象存活的周期将内存分为几块，然后每块使用不同的垃圾回收算法。

比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除“或“标记-整理”算法进行垃圾收集。

### 垃圾回收器

1. Serial收集器：利用单线程进行垃圾回收，在工作的时候其他线程也要停止工作。新生代采用复制算法，老年代采用标记-整理算法
    
2. ParNew收集器：多线程版的Serial收集器
    
3. Parallel Scavenge收集器：主要关注的是吞吐量。新生代采用复制算法，老年代采用标记-整理算法
    
4. Serial Old收集器：Serial收集器的老年代版本，单线程的收集器。主要用于JDK1.5前配合Parallel Scavenge收集器使用和作为CMS收集器的后备方案
    
5. Parallel Old收集器
    
6. CMS收集器：Concurrent Mark Sweep Collector是一种以获取最短回收停顿时间为目标的收集器。回收过程主要分为以下四个步骤：
    
    初始标记 → 并发标记 → 重新标记 → 并发清除
    
    三个明显的缺点：
    
    1. 对CPU资源敏感
    2. 无法处理浮动垃圾
    3. 它使用的回收算法会导致大量的空间碎片
7. G1收集器：Garbage First是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器，以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征
    
    具备以下特点：
    
    1. 并行与并发
    2. 分代收集：虽然G1可以独立管理的GC堆，但还是保留了分代的概念
    3. 空间整合
    4. 可预测的停顿
    
    运行步骤
    
    初始标记 → 并发标记 → 最终标记 → 筛选回收
    
    G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region
    

## 类加载

### 类的生命周期

`加载 —> 连接 —> 初始化 —> 使用 —> 卸载`

连接阶段包括：`验证 —> 准备 —> 解析`

### 类加载过程

系统加载类的过程为：`加载 —> 连接 —> 初始化`，其中连接阶段包括：`验证 —> 准备 —> 解析`

### 加载

主要完成三件事：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的`Class`对象,作为方法区这些数据的访问入口

一个非数组类的加载阶段是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。

### 验证

`文件格式验证 —> 元数据验证 —> 字节码验证 —> 符号引用验证`

### 准备

正式为类变量分配内存并设置类初始化值的阶段：

1. 这个时候进行内存分配的仅包括类变量，而不包括实例变量
2. 所设置的初始值"通常情况"下是数据类型默认的零值

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

### 初始化

真正执行类中定义的Java程序代码，初始化阶段是执行类构造器`<clinit>()`方法的过程，虚拟机会保证此方法在多线程环境中的安全性，因为其是带锁的方法，在多线程环境下会引发不易被发现的死锁。

### 卸载

卸载类即该类的Class对象被GC。需要满足三个条件：

1. 该类的所有实例对象都被GC
2. 该类没有在其他任何地方被引用
3. 该类的类加载器的实例被GC

由JVM自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是会被卸载的。

### 类加载器

JVM内置了三个类加载器

1. `BootstrapClassLoader`：最顶层的类加载器，由C++实现，负载加载`%JAVA_HOME/lib%`目录下的jar包和类，还有被`-Xbootclasspath`参数指定的路径中的所有类
2. `ExtensionClassLoader`：加载`%JRE_HOME%/lib/ext`下的jar包和类，或被`java.ext.dirs`系统变量所指定的路径下的jar包
3. `AppClassLoader`：面向用户的加载类，加载当前应用`classpath`下的jar包和类

### 双亲委派模型

即在类加载的时候，会先判断当前类是否被加载过。已经加载过的类会直接返回，否则尝试加载类。

加载的时候，首先使用该类的父类加载器的`loadclass`处理，当父类加载器无法处理时，才由自己处理。当父类加载器为`null`时，会使用`BoostrapClassLoader`作为父类加载器。

自低向上检查类是否被加载，自顶向下尝试加载类

好处：

1. 避免类的重复加载
2. 也保证Java的核心API不被篡改，比如不适用，就会出现自己定义一个`java.lang.Object`，导致出现多个Object类

不使用双亲委派的方法：自定义类加载器，然后重写`loadClass`方法。

不想打破双亲委派机制则自定义类加载器的时候重写`findClass`方法

## JVM调优

### 原则

1. 多数的JVM应用不需要再服务器上进行GC优化
2. 多数GC问题不是参数设置错误引起的，而是代码问题
3. 应用上线前应当优先将机器上的JVM参数设置道最适合
4. 减少创建对象的数量
5. 减少使用全局变量和大对象
6. GC调优是最后的手段
7. 分析GC日志调优代码比优化GC参数好

### 目的

1. 将转移到老年代的对象降低道最小
2. 减少GC的执行时间

### GC调优测率

1. 将对象预留再新生代
2. 大对象直接进入老年代
3. 合理设置进入老年代对象的年龄
4. 设置稳定的堆大小
5. MinorGC执行时间不到50ms，MinorGC执行不频繁，约10s一次；FullGC执行时间不到1s，FullGC执行不频繁，低于10分钟一次，则不需要调优