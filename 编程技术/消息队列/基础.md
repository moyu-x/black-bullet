## 基础

我们可以把消息队列比作是一个存放消息的容器，当我们需要使用消息的时候可以取出消息供自己使用

### 好处

使用消息队列的好处：

1. 通过异步处理提高系统性能
2. 降低系统耦合性

消息队列使用发布-订阅模式工作，生产者发布消息，一个或多个消费者订阅消息。为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。

### 用途

1. 异步
2. 解耦
3. 削峰

### 问题

1. 系统可用性降低
2. 系统复杂性提高
3. 一致性问题

## JMS

Java Message Service API是一个消息服务的标准（规范），运行应用程序组件给予J2EE平台创建、发送、接收和读取消息。它是分布式通信耦合度变低，消息服务更加可靠以及异步性

### 消息模型

1. 点到点模型：使用队列作为消息通信载体，满足生产者消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。
2. 发布订阅模型：发布订阅模型使用Topic作为消息通信载体。发布者发布消息后，该消息通过Topic发送给所有订阅者，在一条消息广播之后才订阅的用户则是收不到该消息的

### 五种不同的消息正文格式

- StreamMessage
- MapMessage
- TextMessage
- ObjectMessage
- BytesMessage

## AMQP

Advanced Message Queuing Protocol提供统一消息服务的应用层标准。

### 与JMS的对比

- AMQP为消息定义了线路层的协议，而JMS所定义的是Java API规范。
- JMS支持TextMessage、MapMessage等复杂消息类型，而AMQP仅支持`byte[]`消息类型，复杂的消息需要序列化
- 由于Exchange提供路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列

## RabbitMQ

### 核心概念

- Product
- Consumer
- Exchange：用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 Producter，或许会被直接丢弃掉。有四种类型：
    1. direct（默认）：消息路由到那些Bindingkey与RoutingKey完全匹配的Queue中
    2. fanout：把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，常用来广播消息
    3. topic
    4. headers（不推荐）：headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配
- Queue：用来保存消息直到发送给消费者。消息只能存储在Queue中，多个消费者可以订阅同一个队列
- Broker：消息中间件的服务节点

消息有消息头和消息体组成，消息体可被称为Payload，消息体是不透明的，而消息头由一系列可选属性组成。

生产者将消息发给交换器的时候，一般会指定一个RoutingKey，用来指定这个消息的路由规则，而RoutingKey需要与交换器类型和BingKey联合使用才能生效

RabbitMQ中通过Bingding讲Exchange与Queue关联起来，在绑定的时候一般会指定一个BindingKey

### 高可用

其是基于主从模式做的高可用，有三种模式：

1. 单机模式
2. 普通集群模式（无高可用性）：在多台机器上启动多个RabbitMQ实例，创建的Queue，只会放在一个RabbitMQ实例上，但是每个实例都同步 queue的元数据。消费的时候，如果实际上连接到了另外一个实例，那么那个实例会从queue所在实例上拉取数据过来
3. 镜像集群模式（高可用性）：在镜像集群模式下创建的Queue，无论元数据还是queue的消息都会存在多个实例上。

### 保证数据不丢失

**生产者丢数据**

1. 可以选择使用RabbitMQ提供的事务功能，但是这样吞吐量会下来，太消耗性能
2. 一般开启confirm模式：在生产者开启confirm模式，每次写消息都会分配一个唯一id，成功写入则返回ack消息，写入失败返回nack消息，并且可以根据这个id自己维护状态，超时未收到ack或nack可以尝试重试机制

事务机制是阻塞的，confirm模式是异步的

**RabbitMQ丢失数据**

可以开启RabbitMQ的持久化机制，开启后写入的消息会持久化到硬盘。

步骤：

1. 创建Queue时将其设置为持久化
2. 发送消息是将消息的`delivery`设置为2

**消费端丢失数据**

关闭RabbitMQ的自动ack，使用api来手动完成ack

## Kafka

由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。

流平台具有三个关键功能：

1. 消息队列
2. 容错的持久方式存储记录消息流
3. 流式处理平台

应用场景：

1. 消息队列
2. 数据处理

### 队列模型

使用队列作为消息通信载体，满足生产者与消费者模式，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时

问题：我们需要将生产者产生的消息分发给多个消费者，并且每个消费者都能接收到完成的消息内容，这种队列模型不好解决了。

### 发布-订阅模型

发布订阅模型（Pub-Sub）使用主题（Topic）作为消息通信载体，类似于广播模式；发布者发布一条消息，该消息通过主题传递给所有的订阅者，在一条消息广播之后才订阅的用户则是收不到该条消息的。

在发布-订阅模型中，如果只有一个订阅者，那它和队列模型就基本是一样的了。所以说，发布-订阅模型在功能层面上是可以兼容队列模型的。

Kafka 采用的就是发布-订阅模型。

### 保证消息不丢失

- 生产者丢失消息情况：使用重试，重试次数设置为3比较合适
- 消息者丢失消息的情况：和Kafka的offset有关，自动提交offset，当消费者拿到消息准备消费时Kafka崩溃，消息实际上没被消费，但是offset被手动提交，这个时候就会丢失消息。解决办法手动关闭闭自动提交offset，每次在真正消费完消息之后之后再自己手动提交offset
- Kafka丢失消息：leader副本所在的broker突然挂了，那么就要从follower副本中重新选出一个leader，leader中要是一些数据没同步，这个时候就会造成数据丢失
    1. 设置`acks=all`
    2. 设置`replication.factor >= 3`
    3. 设置`min.insync.replicas > 1`
    4. 设置`unclean.leader.election.enable = false`