## Chapter 1 计算机基础

`IP`是面向无连接、无状态的，没有额外的机制保证发送的包是否有序到达。

三次握手是指建立连接的三个步骤，目的是信息对等和防止超时:

1. A 机器发出一个数据包并将`SYN`置 1，表示希望建立连接
2. B 机器受到 A 机器的数据包后，通过`SYN`得知这是一个建立连接的请求，于是发送一个响应包并将`SYN`和`ACK`标记都指 1
3. A 受到 B 的响应包后需要进行确认，确认包中将 ACK 置 1

从编程的角度，`TCP`连接是通过文件描述符完成的

`TCP`断开的时候存在`TIME_WAIT`的原因：

1. 确认被动关闭方能够顺利进入`CLOSED`状态
2. 防止请求丢失

如果是参数配置错误导致的系统宕机，即使增加硬件资源，也无法达到好的效果。硬件的增加于性能的提升绝对不是线性相关的，更多的时候是对数曲线关系。

数据库连接池是一种空间换取时间的策略，但是过多同样会影响性能

从经验上来看，在数据库层面的请求应答时间必须在 100ms 以内，秒级的 SQL 查询通常存在巨大的性能提升空间，应对方案如下：

1. 建立高效且合适的索引
2. 排查连接资源未显示
3. 合并短请求
4. 合理的拆分多个表`join`的 SQL，若是超过三个则禁止`join`
5. 使用临时表
6. 应用层优化
7. 改用其他数据库

需要建立一套完整的信息安全体系，遵循`CIA`原则，既保密性、完整性和可用性

预防`SQL`注入的应该考虑的几个方面

1. 过滤用户输入参数中的特殊字符，从而降低被 SQL 注入的风险
2. 禁止通过字符串拼接的 SQL 语句，严格使用参数绑定传入的 SQL 参数
3. 合理使用数据库访问框架提供的防注入机制

## Chapter 2 面向对象

### 面向对象

`OOP`的三大特性：封装、继承、多态

软件工程的三个主要目标：可维护性、可重用性和可扩展性

面向过程的结构相对松散，强调如何流程化的解决问题；面向对象的思维更加内聚，强调搞内聚、低耦合，先抽象模型，定义共性行为，再解决实际问题，再解决实际问题。

浅拷贝只复制当前对象的所有基本数据类型，以及相应的引用变量，但没有复制引用变量指向的实际对象；而彻底深拷贝实在成功`clone`一个对象之后，此对象与母对象在任何引用路径上都不存在共享实例对象，但是引用路径递归越深，则约接近`JVM`底层对象，且发现彻底拷贝实现难度大。介于浅拷贝和彻底深拷贝之间的都是一般深拷贝。归根到底，慎用`Object`的`clone()`方法来拷贝对象，因为对象的`clone()`方法默认是浅拷贝。

里氏代换原则是指任何父类能够出现的地方，子类都能够出现。

多态是指在编译层面无法确定最终调用方法体，以覆写为基础来实现面向对象特性，在运行期由`JVM`进行动态绑定，调用合适的覆写方法体来执行。重在是编译期确定方法调用，属于静态绑定，本质上重载的结果是完全不同的方法。

### 类设计

抽象类是模板式设计，而接口是契约式设计。

抽象类包含一组相对具体的特征

外部类与内部类之间使用`$`符号分隔，匿名内部类使用数字进行编号，而方法内部类在类名浅还有一个编号来标识是哪个方法。

定义报能可见静态内部类的好处是：

1. 作用域不会扩散到包外
2. 可以通过“外部类.内部类”的方式直接访问
3. 内部类可以访问外部类中的所有静态属性和方法

访问级别控制：

1. 如果不允许外部直接通过`new`创建对象，构造方法必须是`private`的
2. 工具类那个不允许有`public`或`default`构造方法
3. 类非`static`成员变量并且与子类共享，必须是`protected`
4. 类非`static`成员变量并且仅在本类使用，必须是`private`
5. 类`static`成员变量如果仅在本类使用，必须是`private`
6. 若是`static`成员变量，必须考虑是否为`final`
7. 类成员方法只提供类内部调用，必须是`private`
8. 类成员方法只对继承公开，那么限制为`protected`

任何类在创建之处，都有一个默认的空构造方法，它是`super()`的一条默认通路。

一个实例变量可以通过`this.`赋值另一个实例变量；一个实例方法可以通过`this.`调用另一个实例方法；甚至一个构造方法都可以通过`this.`调用另一个构造方法。

类关系情况：

- 继承(is-a)
- 实现(can-do)
- 组合(contains-a)
- 聚合(has-a)
- 依赖(use-a)

将数据对象转换为二进制流的过程称为对象的序列化，将二进制流恢复为数据对象的过程称为反序列化。

有些对象的敏感属性不需要进行序列化传输，可以加`transient`关键字，避免把此属性信息转换为序列化的二进制流

### 方法

参数预处理包括两种：

1. 入参保护
2. 参数校验

静态方法需要注意的地方：

1. 静态方法中不能使用实例成员变量和实例方法
2. 静态方法不能使用`super`和`this`关键字，这两个关键子指代的都是需要被创建出来的对象

在实际应用中如初始化容器时，可以使用静态代码块加载判断、属性初始化、环境配置等。

`POJO`专门指只包含`getter`、`setter`、`toString`方法的简单类。

`getter`和`setter`中错误使用的定义方式：

1. `getter/setter`中添加业务了逻辑
2. 同时定义`isXxx()`和`getXxx()`
3. 相同的属性名容易带来歧义

如果某个类覆写了父类的某个方法，则方法表中的方法指向会指向子类的实现处。

向上转型时，通过父类引用执行子类方法需要注意：

1. 无法调用到子类中存在而父类本身不存在的方法
2. 可以调用到子类中覆写了父类的方法，这是一种多态实现

成功覆写父类方法，需要满足的四个条件，并且只能针对非静态、非`final`、非构造方法：

1. 访问权限不能变小
2. 返回类型能够向上转型成为父类的返回类型
3. 异常也要能向上转型成为父类异常
4. 方法名，参数类型及个数必须严格一致

### 重载

`JVM`重载方法顺序的选择方式：

1. 精准匹配
2. 如果是基本数据类型，自动转换程更大表示范围的基本类型
3. 通过自动拆箱和装箱
4. 通过子类向上转型继承路线依次匹配
5. 通过可变参数匹配

### 数据类型

`refvar`是基本数据类型，它的默认值是`null`，存储`refobj`的首地址，可以直接使用双等号`==`进行等值判断。

一个`refvar`至多存储一个`refobj`的首地址，一个`refobj`可以被多个`refvar`存储下它的首地址，即一个堆内对象可以被多个`refvar`引用指向

![[assets/a96dc6565f735644bf52e29ba27705d1_MD5.jpg]]

对象头

对于在-128 到 127 直接的`Integer`对象由`IntegerCache.cache`产生，会复用已有的对象，这个区间可以直接使用`==`进行判断，但是这个区间外的所有数据都会在堆上产生，并不会复用已有对象，所以包装类型都使用`equals()`进行比较

包装类型和基础数据类型的选择：

1. 所有的`POJO`类属性必须使用包装数据类型
2. `RPC`方法的返回值和参数必须使用包装数据类型
3. 所有的局部变量推荐使用基本数据类型

`StringBuilder`是非线程安全的，线程安全的对象先产生是因为计算机的发展总是从单线程到多线程，从单机到分布式

## Chapter 3 代码风格

命名上可体现出代码元素的特征，仅从名字上可知道代码元素的属性是什么，有利用快速厘清代码脉络。

命名需要遵守的约定:

1. 命名符合本语言特性
2. 命名体现现代代码元素特征
3. 命名最好望文知意

空格使用的约定：

1. 任何二目、三目运算符的左右两边都必须加一个空格
2. 注释的双斜线与注释内容之间有 0 仅有一个空格。
3. 方法参数在定义和传入时，多个参数逗号后边心须加空格。
4. 没有必要增加若十空格使变量的赋值等号与上一行对应位的等号对齐。
5. 如来是大括号内为空，则简洁地写成`{}`即可，大括号中间无须焕行和空格
6. 左右小括号与括号内部的相邻字符之间不要出现空格
7. 左在大括号前需要加空格。

约定单个方法的总行数不超过 80 行。

多层嵌套不能超过三层，避免采用反逻辑运算符

## Chapter 4 走进 JVM

### 字节码

字节码主要指令如下：

1. 加载或存储指令
    1. 讲局部变量加载到操作栈种
    2. 从操作栈顶存储到局部变量表
    3. 讲常量加载到操作栈顶
2. 运算指令
3. 类型转换指令
4. 对象创建与访问指令
    1. 创建对象指令
    2. 访问属性指令
    3. 检查实例类型指令
5. 操作栈管理指令
    1. 出栈操作
    2. 复制栈顶元素并压入栈
6. 方法调用与返回指令
    1. `INVOKEVIRTUAL`指令
    2. `INVOKESPACIAL`指令
    3. `INVOKESTATIC`指令
    4. `RETURN`指令
7. 同步指令

![[assets/4cc1376a1eda4ba9b157caf0ab33cd3a_MD5.jpg]]

源码转换为字节码过程

执行有三种模式：

1. 解释执行
2. `JIT`编译执行
3. `JIT`编译与混合执行

![[assets/4e1ece41acfd6d42d9f622dfc3757875_MD5.jpg]]

即时编译流程

机器在热机状态可以承受的负载要大于冷机状态，如果以热机状态是的浏览进行切换，可能使处于冷机状态的服务器因无法承载流量而假死

### 类加载过程

主要流程：

1. `LOAD`阶段读取类文件产生的二进制流，并转换为特定的数据结构
2. `Link`阶段包括验证、准备、解析三个步骤
3. `Init`阶段执行类构造器`<clinit>`方法，如果赋值运算是通过其他类的静态方法来完成的，如果马上解析另外一个类，在虚拟机栈种执行完毕后柘荣刚返回值进行赋值

类加载过程是一个讲`.class`字节码文件实例化程`Class`对象并进行相关初始化的过程

`new`是强类型校验，可以调用任何构造方法，在使用`new`操作的时候，这个类可以没有被加载过。而`Class`类下的`newInstance`是弱类型，只能调用无参构造方法，如果没有默认的构造方法，就抛出`InstantiationExeception`异常，如果此构造器没有访问权限，就抛出`IllegalAccessExeception`

通过`setAccessible(true)`操作，可以是用大写`Class`类的`set`方法修改其值

`AppClassLoader`的`Parent`为`Bootstrap`

![[assets/1888aa2cca42b1889927cbdd71b18d37_MD5.jpg]]

双亲委派模型

低层次的当前类加载器，不能覆盖更高层次类加载的类

自定义类加载器的情况：

1. 隔离加载类
2. 修改类加载方式
3. 扩展加载源
4. 防止源码泄露

实现自定义类加载器的步骤：继承`ClassLoader`，重写`findClass()`方法，调用 `defineClass()`方法。

### 内存布局

![[assets/663acc4468fa9eda948d09bd7826d5b5_MD5.jpg]]

内存布局

![[assets/6cba8bd121da15c41c7ec42d20956628_MD5.jpg]]

GC过程

栈帧包括局部变量表、操作栈、动态连接、方法返回地址等

从字节码角度看待对象的创建过程：

1. `NEW`：如果找不到`Class`对象，则进行类加载
2. `DUP`：在栈顶赋值该引用变量，这时的栈顶有两个指向堆内实例对象的引用变量
3. `INVOKESPECIAL`：调用对象实例方法，通过栈顶的引用变量调用`<init>`方法

从执行步骤的角度：

1. 确认类源信息是否存在
2. 分配对象内存
3. 设定默认值
4. 设定对象头
5. 执行`init`方法

### 垃圾回收

如果一个对象与`GCRoots`之间没有直接或间接的引用关系，比如某个失

去任何引用的对象，或者两个互相环岛状循环引用的对象等，判决这些对象“死缓是可以被回收的。

![[assets/4231d170f889da51af426b4a48379da9_MD5.jpg]]

Servial 回收流程

## Chapter 5 异常与日志

异常捕获是针对飞稳定代码的，捕获时要区分异常类型并做相应处理。

无论采用哪种方式处理异常，都严禁捕获异常后什么都不做或打印一行日志了事。如果在方法内部处理异常，需要根据不同的业务场景进行定制处理，如重试、回滚等操作。如果向上抛出异常，如上例所示，需要在异常对象中添加上下文参数、局部变量、运行环境等信息，这样有利于排查问题。

![[assets/28877c59ff8d5e2b85bea5d68193234c_MD5.jpg]]

异常结构分类

如果`finally`代码块没有执行，可能有三种情况：

- 没有进入`try`代码块
- 进入`try`代码块，但是代码运行种出现了死循环或死锁状态
- 进入`try`代码块，但是执行了`System.exit()`

`finally`代码块的职责不在于堆变量进行赋值等操作，而是清理资源、释放连接、关闭管道流等操作，此时如果发送异常也要进行捕获

在`try`代码块之前调用`lock()`方法，避免由于加锁失败导致`finanlly`调用`unlock()`抛出异常

推荐对外提供的凯放接口使用错误码了；公司内部跨应用远程服务调用优先考虑使用`Result`对象来封装错误码、错误描述对象；而应用内部则推荐直接抛出异常对象

记录系统日志主要有三个原因：记录操作轨迹、监控系统运行状况、回溯系统故障

包装记录的完整：

1. 记录异常时一定要输出异常堆栈
2. 日志种如果输出对象实例，要确保类实例重写了`toString`方法，否则只会输出对象的`hashCode`，没有实际意义

![[assets/50faaaa67dcd6ffb59fc6515539352d8_MD5.jpg]]

日志结构框架

## Chapter 6 数据结构与集合

### 集合

![[assets/7b5924c700c4660c46b99edd28f18a0d_MD5.jpg]]

Java 集合架构图

`ArrayList`是容量可变的非线程安全集合

`HashMap`从源码分析是使用`HashMap`来实现的

在`Java`体系种，数组可以存储统一类型的对象，一旦分配内存后则无法扩容

在数组转集合的过程中，注意是否使用了视图方式直接返回数组中的数据，例如当使用`Arrays.asList()`讲数组转换为集合时，不能使用其修改集合相关的方法，其体现的是适配器模式。`asList`的返回对象是一个`Arrays`的内部类，它并没有实现集合个数的相关修改方法

不要使用`toArray()`的无参方法把集合转换成数组，这样会导致泛型丢失。使用集合的`toArry(T[] array)`方法，转换为数组时，注意需要传入类型完全一样的数组，并且它的容量大小为`list.size()`

### 集合泛型

`List<?>`是一个泛型，在没有赋值之前，表示它可以接受任何类型的集合赋值，赋值之后就不能随便往里添加元素了

`<? extends T>`是`Get First`，适用于消费集合元素为主的场景，可以赋值给任何`T`及`T`子类的集合，上界为`T`，取出来的类型带有泛型限制，向上强制转型为`T`，`null`可以表示任何类型，所以除了`null`外，任何元素都不能添加进`<? extends T>`

`<? super T>`是`Put First`的，生产集合元素为主的场景，可以赋值给任何`T`及`T`父类的集合，下界为`T`

`extents`的场景是`put`受限，而`super`场景是`get`受限

### 元素比较

`Comparable`是自己和自己比，`Comparator`是第三方比较器，约定小于的情况返回`-1`，等于的情况返回`0`，大于的情况返回`1`

`hashCode`和`equals`的要求如下：

1. 如果两个对象的`equals`的结果是相等的，则两个对象的`hashCode`的返回结果必须是相同的
2. 任何时候覆写`equals`都必须同时覆写`hashCode`

`Objects.hashCode()`的实现是默认为每一个对象生成`int`数值，其本身是根据对象的地址进行相关计算得到的`int`类型数据

`subList`方法返回的是内部类`SubList`的对象，`SubList`类是`ArrayList`的内部类

`java.util`下的所以集合类都是`fail-fast`机制，而`concurrent`包种的集合类都是`fail-safe`

使用`CopyOnWriteArrayList`的时候应该注意：

1. 尽量设置合理的容量初始值
2. 使用批量添加或删除方法

## Chapter 7 并发与多线程

在并发环境下，由于程序的封闭性被打破，出现以下特点：

1. 并发程序之间有相互制约的关系
2. 并发程序的执行过程是断断续续的
3. 当并发数设置合理并且`CPU`拥有足够处理能力时，并发会提高程序的运行效率

### 线程安全

线程可以拥有自己的操作栈、程序计数器、局部变量表等资源，它于同一进程内的其他线程共享该进程的所有资源

![[assets/e8829d022d351394f7f911792ad39aeb_MD5.jpg]]

创建线程的三种方式：

1. 继承`Thread`类
2. 实现`Runnable`接口
3. 实现`Callable`接口

继承`Thread`的类往往不符合里氏代换原则

保证高并发场景下线程安全可以从四个方面考虑:

1. 数据单线程内可见
2. 只读对象
3. 线程安全类
4. 同步与锁机制

线程安全理念的核心就是“要么只读，要么加锁”

并发包的主要组成：

1. 线程同步类
2. 并发集合类
3. 线程管理类
4. 锁相关操作

### 锁

锁主要提供了两种特性：

- 互斥性
- 分段性

![[assets/7e4e94d233dcdde1cfc60ce2fbe3a08d_MD5.jpg]]

在`AQS`中定义了一个`volatile int state`变量作为共享资源，如果线程获取资源失败，则进入同步`FIFO`队列中等待；如果成功获取资源就执行临界代码。执行完释放资源时，会通知同步队列中的等待线程来获取资源出队并执行。其是抽象类，内置自旋锁实现同步队列，封装入队和出队操作，提供独占、共享、中断等特性方法。

`CountDownLatch`是一次性的，用完后如果想再使用就只能重新创建一个；循环使用则使用基于`ReentrantLook`实现的`CyclicBarrier`

`synchronized`的原则是锁的范围要小，时间尽可能的短，即能锁对象就不要锁类，能锁代码块就不要锁方法

`JVM`底层是通过监视锁来实现`synchronzied`的，`JVM`会根据`synchronized`的当前环境，找到对应对象的`monitor`，再根据`monitor`的状态进行加、解锁的判断。

### 线程同步

对`volatile`变量的操作都并非都具有原子性

`LongAdder`类比`AtomicLong`性能更好，因为有效的减少了乐观锁的重试次数

一写多读的并发场景使用`volatile`修饰比变量最为合适

无论是从性能还是从安全上考虑，尽量使用并发包中提供的信号同步类，避免使用对象的`wait()`和`notify()`

### 线程池

友好拒绝的策略：

1. 保存到数据库进行削峰填谷，在空闲时再取出来执行
2. 转向某个提示页面
3. 打印日志

![[assets/6c482660f26fbd887bff7fe8f05177bd_MD5.jpg]]

线程状态图

`Executors`核心方法有五个：

- `Executors.newWorkStealingPool`创建持有阻隔线程池支持给定的并行度，并通过使用多个队列减少竞争，此构造方法中把`CPU`数量设置为默认的并行度
- `Executors.newScheduledThreadPool`线程数最大为`Integer.MAX_VALUE`，存在`OOM`风险
- `Executors.newSingleThreadExecutor`创建一个单线程的线程池，相当于单线程串行执行所有任务，保证按任务的提交顺序依次执行
- `Executors.newFixedThreadPool`输入的参数即是固定的线程数，既是核型线程数也是最大线程数，不存在空闲线程，所有`keepAliveTime`等于 0

`ThreadPoolExecutor`提供四个公开的内部静态类：

- `AbortPolicy`丢弃任务并抛出`RejectedExecutionException`异常
- `DiscardPolicy`丢弃任务，但是不抛出异常，不推荐使用
- `DiscardOldestPolicy`抛弃队列中等待最久的任务，然后把当前任务加入队列中
- `CallerRunsPolicy`调用任务的`run()`方法绕过线程池直接执行

线程池使用的注意事项：

1. 合理设置各类参数，应根据实际业务场景来设置合理的工作线程数
2. 线程资源必须通过线程池提供，不允许在应用中自行显示创建线程
3. 创建线程或线程池时请制定有意义的线程名称，方便出错回溯

线程池不允许使用`Executors`，而是通过`ThreadPoolExecutor`的方式创建

### ThreadLocal

![[assets/06fda7c0e5c198f2c278b350341a7634_MD5.jpg]]

对象头内部结构

`ThreadLocal`的副作用：

1. 脏数据
2. 内存泄漏

## Chapter 8 单元测试

宏观上单元测试要符合`AIR`原则，微观上单元测试的代码要符合`BCDE`原则

`AIR`：自动化、独立性、可重复

`BCDE`：边界测试、正确的输入、与设计文档相结合、单元测试的目标是证明程序有错，而不是证明程序无错

`MOCK`的本质是写出更加稳定的单元测试，隔离对单元测试影响的因素，使结果变得可预测，做到真正的‘单元’测试

单元测试的粒度：

1. 粗粒度的覆盖
2. 细粒度的覆盖
3. 行覆盖
4. 分支覆盖
5. 条件判定覆盖
6. 条件组合覆盖
7. 路径覆盖

## Chapter 9 代码规约

代码规约的意义：

1. 码出高效
2. 码出质量
3. 码出情怀